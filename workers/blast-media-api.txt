export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);

    // CORS preflight
    if (request.method === "OPTIONS") {
      return new Response(null, { status: 204, headers: corsHeaders() });
    }

    try {
      const pathname = normalizePath(url.pathname, ["/media"]);

      // ---------- Public ----------
      // GET /media/list
      if (request.method === "GET" && (pathname === "/list" || pathname === "/media/list")) {
        return withCors(await handleList(env));
      }

      // Serve images:
      // GET /media/web/<filename>
      // GET /media/thumb/<filename>
      if (request.method === "GET" && (pathname.startsWith("/web/") || pathname.startsWith("/thumb/"))) {
        return withCors(await handleServeR2(request, env, pathname));
      }

      // ---------- Admin ----------
      // POST /media/admin/rebuild
      if (request.method === "POST" && (pathname === "/admin/rebuild" || pathname === "/media/admin/rebuild")) {
        requireAdmin(request, env);
        return withCors(await handleRebuild(env));
      }

      return withCors(json({ ok: false, error: "Not found" }, 404));
    } catch (err) {
      return withCors(
        json(
          {
            ok: false,
            error: "Worker error",
            detail: err?.message || String(err),
          },
          500
        )
      );
    }
  },
};

/* ------------------------- Core Handlers ------------------------- */

async function handleList(env) {
  const db = getDB(env);

  // 只输出已批准
  const rows = await db
    .prepare(
      `SELECT photo_id, ext, content_type, created_at, approved_at, photo_key
       FROM photos
       WHERE status='approved'
       ORDER BY photo_id ASC`
    )
    .all();

  const items = (rows.results || []).map((r) => {
    const name = r.photo_key || `HADO (${r.photo_id}).${r.ext || "jpg"}`;

    // 关键：对文件名做 encode，避免空格导致 URL 与 R2 key 不一致
    const encName = encodeURIComponent(name);

    return {
      id: r.photo_id,
      name,
      web: `/media/web/${encName}`,
      thumb: `/media/thumb/${encName}`,
      created_at: r.created_at || null,
      approved_at: r.approved_at || null,
    };
  });

  return json({ ok: true, count: items.length, items });
}

async function handleServeR2(request, env, pathname) {
  const bucket = getBucket(env);

  // pathname: "/web/<encodedName>" or "/thumb/<encodedName>"
  // R2 key: "web/<decodedName>" or "thumb/<decodedName>"
  const parts = pathname.split("/");
  // ["", "web", "<encodedName...>"]
  if (parts.length < 3) return json({ ok: false, error: "Bad path" }, 400);

  const folder = parts[1]; // "web" or "thumb"
  const encodedName = parts.slice(2).join("/"); // 防御性
  const decodedName = decodeURIComponent(encodedName);

  const key = `${folder}/${decodedName}`;

  const obj = await bucket.get(key);
  if (!obj) {
    return json({ ok: false, error: "Not found", key }, 404);
  }

  const headers = new Headers();
  headers.set("ETag", obj.httpEtag || obj.etag || "");
  headers.set("Cache-Control", "public, max-age=31536000, immutable");
  headers.set("Content-Type", obj.httpMetadata?.contentType || guessContentType(decodedName));

  // 支持 Range（视频/大文件也更稳；图片也不坏）
  const range = request.headers.get("Range");
  if (range) {
    const r = obj.range;
    if (r) {
      const res = await obj.body?.getReader?.(); // 有些环境不需要，保留
    }
  }

  return new Response(obj.body, { status: 200, headers });
}

async function handleRebuild(env) {
  const t0 = Date.now();
  const db = getDB(env);
  const bucket = getBucket(env);

  // 备份 uploads（如果存在）
  await safeExec(db, `DROP TABLE IF EXISTS uploads_backup_t0_5`);
  await safeExec(db, `CREATE TABLE IF NOT EXISTS uploads_backup_t0_5 AS SELECT * FROM uploads`);

  // 清空 photos 并重建（路线1：R2 -> D1 photos）
  await safeExec(db, `DELETE FROM photos`);

  let cursor = undefined;
  let inserted = 0;

  // 我们以 thumb/ 为准：它最稳定且数量与你说的 255 一致
  while (true) {
    const listed = await bucket.list({ prefix: "thumb/", cursor, limit: 1000 });
    const objects = listed.objects || [];

    if (objects.length) {
      const batch = [];
      for (const o of objects) {
        const key = o.key; // "thumb/HADO (12).jpg"
        const parsed = parseHadoKey(key);
        if (!parsed) continue;

        batch.push(parsed);
      }

      // 批量写入 photos
      if (batch.length) {
        const stmts = batch.map((p) =>
          db
            .prepare(
              `INSERT INTO photos (receipt, ext, content_type, status, created_at, approved_at, photo_id, photo_key)
               VALUES (NULL, ?, ?, 'approved', ?, ?, ?, ?)`
            )
            .bind(
              p.ext,
              guessContentType(p.name),
              new Date().toISOString(),
              new Date().toISOString(),
              p.photo_id,
              p.name
            )
        );

        // D1 batch
        const res = await db.batch(stmts);
        inserted += batch.length;
      }
    }

    if (listed.truncated) {
      cursor = listed.cursor;
    } else {
      break;
    }
  }

  const elapsed_ms = Date.now() - t0;
  return json({
    ok: true,
    mode: "route1_r2_to_d1_photos",
    inserted,
    elapsed_ms,
  });
}

/* ------------------------- Helpers ------------------------- */

function parseHadoKey(key) {
  // key: "thumb/HADO (12).jpg" or "web/HADO (12).png"
  // 只接受 web/ 或 thumb/
  if (!key.startsWith("thumb/") && !key.startsWith("web/")) return null;

  const name = key.split("/").slice(1).join("/"); // "HADO (12).jpg"
  // 允许 "HADO(12).jpg" 和 "HADO (12).jpg"
  const m = name.match(/^HADO\s*\((\d+)\)\.(\w+)$/i);
  if (!m) return null;

  const photo_id = Number(m[1]);
  const ext = m[2].toLowerCase();

  // 统一为带空格的标准名：HADO (n).ext
  const normalizedName = `HADO (${photo_id}).${ext}`;

  return {
    photo_id,
    ext,
    name: normalizedName,
  };
}

function getBucket(env) {
  // 兼容 BUCKET / MEDIA_BUCKET
  const b = env.BUCKET || env.MEDIA_BUCKET;
  if (!b) throw new Error("Missing R2 binding: BUCKET (or MEDIA_BUCKET)");
  return b;
}

function getDB(env) {
  if (!env.DB) throw new Error("Missing D1 binding: DB");
  return env.DB;
}

function requireAdmin(request, env) {
  const auth = request.headers.get("Authorization") || "";
  const token = auth.startsWith("Bearer ") ? auth.slice(7) : "";
  if (!env.ADMIN_TOKEN) throw new Error("Missing ADMIN_TOKEN in env");
  if (token !== env.ADMIN_TOKEN) {
    const e = new Error("Unauthorized");
    e.status = 401;
    throw e;
  }
}

async function safeExec(db, sql) {
  try {
    await db.prepare(sql).run();
  } catch (_) {
    // ignore
  }
}

function normalizePath(pathname, stripPrefixes = []) {
  let p = pathname || "/";
  for (const pref of stripPrefixes) {
    if (p === pref) return "/";
    if (p.startsWith(pref + "/")) p = p.slice(pref.length);
  }
  return p;
}

function json(obj, status = 200) {
  return new Response(JSON.stringify(obj, null, 2), {
    status,
    headers: {
      "Content-Type": "application/json; charset=utf-8",
      ...corsHeaders(),
    },
  });
}

function withCors(resp) {
  const h = new Headers(resp.headers);
  const cors = corsHeaders();
  Object.entries(cors).forEach(([k, v]) => h.set(k, v));
  return new Response(resp.body, { status: resp.status, headers: h });
}

function corsHeaders() {
  return {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "GET,POST,OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type, Authorization, X-Internal-Token",
  };
}

function guessContentType(name) {
  const lower = (name || "").toLowerCase();
  if (lower.endsWith(".png")) return "image/png";
  if (lower.endsWith(".jpg") || lower.endsWith(".jpeg")) return "image/jpeg";
  if (lower.endsWith(".webp")) return "image/webp";
  return "application/octet-stream";
}
