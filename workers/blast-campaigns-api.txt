export default {
  async fetch(request, env) {
    try {
      const url = new URL(request.url);
      if (request.method === "OPTIONS") return corsPreflight();
      if (request.method !== "GET") return json({ error: "Method Not Allowed" }, 405);

      switch (url.pathname) {
        case "/api/public/health":
          return json({ ok: true, ts: new Date().toISOString() });
        case "/api/public/campaigns_bundle":
          return campaignsBundle(env, url);
        case "/api/public/team_bundle":
          return teamBundle(env, url);
        case "/api/public/player_bundle":
          return playerBundle(env, url);
        default:
          return json({ error: "Not Found" }, 404);
      }
    } catch (e) {
      return json({ error: e.message }, 500);
    }
  }
};

function corsPreflight() {
  return new Response(null, { status: 204, headers: corsHeaders() });
}

function json(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: { ...corsHeaders(), "content-type": "application/json" }
  });
}

function corsHeaders() {
  return {
    "access-control-allow-origin": "*",
    "access-control-allow-methods": "GET,OPTIONS",
    "access-control-allow-headers": "*"
  };
}

async function campaignsBundle(env, url) {
  const event_id = url.searchParams.get("event_id") || "hpl";

  const events = await env.DB.prepare(
    "SELECT event_id, name_zh AS name FROM events ORDER BY event_id"
  ).all();

  const seasons = await env.DB.prepare(
    "SELECT season_id, name, status FROM seasons WHERE event_id = ? ORDER BY start_date DESC"
  ).bind(event_id).all();

  const season_id = url.searchParams.get("season_id") || seasons.results[0]?.season_id;

  const divisions = await env.DB.prepare(
    "SELECT division_key, name FROM divisions WHERE season_id = ?"
  ).bind(season_id).all();

  const division_key = url.searchParams.get("division_key") || divisions.results[0]?.division_key;

  const rounds = await env.DB.prepare(
    "SELECT component_id AS round_key, name, component_type AS type FROM score_components WHERE season_id = ? AND leaderboard_key = ? ORDER BY sort_order"
  ).bind(season_id, division_key).all();

  const round_key = url.searchParams.get("round_key") || rounds.results.slice(-1)[0]?.round_key;

  const leaderboard = await env.DB.prepare(
    "SELECT t.team_id, t.name AS team_name, COALESCE(SUM(p.points),0) AS points      FROM teams t      LEFT JOIN team_component_points p ON p.team_id = t.team_id AND p.component_id = ?      GROUP BY t.team_id      ORDER BY points DESC, t.team_id"
  ).bind(round_key).all();

  const table = leaderboard.results.map((r, i) => ({
    rank: i + 1,
    team_id: r.team_id,
    team_name: r.team_name,
    points: r.points
  }));

  return json({
    context: { event_id, season_id, division_key, round_key },
    selectors: {
      events: events.results,
      seasons: seasons.results,
      divisions: divisions.results,
      rounds: rounds.results
    },
    overview: {
      teams_total: table.length,
      teams_scored: table.filter(r => r.points > 0).length,
      teams_zero_score: table.filter(r => r.points === 0).length
    },
    table
  });
}

async function teamBundle(env, url) {
  const team_id = url.searchParams.get("team_id");
  if (!team_id) throw new Error("team_id required");

  const team = await env.DB.prepare(
    "SELECT team_id, name FROM teams WHERE team_id = ?"
  ).bind(team_id).first();

  const aliases = await env.DB.prepare(
    "SELECT alias FROM team_aliases WHERE team_id = ?"
  ).bind(team_id).all();

  const roster = await env.DB.prepare(
    "SELECT p.player_id, p.name AS display_name      FROM rosters r JOIN players p ON r.player_id = p.player_id      WHERE r.team_id = ?"
  ).bind(team_id).all();

  const points = await env.DB.prepare(
    "SELECT component_id, points FROM team_component_points WHERE team_id = ?"
  ).bind(team_id).all();

  return json({
    team: { ...team, aliases: aliases.results.map(a => a.alias) },
    summary: {
      points_total: points.results.reduce((s, r) => s + r.points, 0),
      components_played: points.results.length
    },
    roster: roster.results,
    components: points.results
  });
}

async function playerBundle(env, url) {
  const player_id = url.searchParams.get("player_id");
  if (!player_id) throw new Error("player_id required");

  const player = await env.DB.prepare(
    "SELECT player_id, name, nickname FROM players WHERE player_id = ?"
  ).bind(player_id).first();

  const rosters = await env.DB.prepare(
    "SELECT r.team_id, t.name AS team_name, r.season_id      FROM rosters r JOIN teams t ON r.team_id = t.team_id      WHERE r.player_id = ?"
  ).bind(player_id).all();

  return json({
    player,
    summary: {
      seasons_played: new Set(rosters.results.map(r => r.season_id)).size,
      teams_played: new Set(rosters.results.map(r => r.team_id)).size
    },
    rosters: rosters.results
  });
}